import json
import math

class OrigamiValidator:
    # --- 前回実装した __init__ メソッド (変更なし) ---
    def __init__(self, fold_data: dict):
        self.vertices_coords = fold_data.get("vertices_coords", [])
        self.creases_vertices = fold_data.get("creases_vertices", [])
        self.creases_assignment = fold_data.get("creases_assignment", [])

        self.vertex_to_creases = [[] for _ in range(len(self.vertices_coords))]
        for i, crease in enumerate(self.creases_vertices):
            v1_index = crease[0]
            v2_index = crease[1]
            # 範囲外アクセスを防ぐ基本的なチェックを追加
            if v1_index < len(self.vertex_to_creases):
                self.vertex_to_creases[v1_index].append(i)
            if v2_index < len(self.vertex_to_creases):
                self.vertex_to_creases[v2_index].append(i)

    # --- 前回実装した check_maekawa メソッド (変更なし) ---
    def check_maekawa(self) -> int:
        violation_count = 0
        for connected_creases in self.vertex_to_creases:
            mountain_count = 0
            valley_count = 0
            for crease_index in connected_creases:
                assignment = self.creases_assignment[crease_index]
                if assignment == 'M': mountain_count += 1
                elif assignment == 'V': valley_count += 1
            
            if mountain_count + valley_count > 0:
                if abs(mountain_count - valley_count) != 2:
                    violation_count += 1
        return violation_count

    # --- ★★★ 新しく実装する check_kawasaki メソッド ★★★ ---
    def check_kawasaki(self) -> int:
        """
        全ての頂点に対して川崎の定理をチェックし、違反している頂点の総数を返します。

        川崎の定理: 頂点の周りの交互の角度の和は180度(π)に等しい。
        """
        violation_count = 0
        EPSILON = 1e-9  # ORIPAを参考にした許容誤差

        # 各頂点についてループ
        for v_center_idx, connected_creases_indices in enumerate(self.vertex_to_creases):
            if not connected_creases_indices:
                continue

            # 1. 頂点周りの角度を計算
            angles = []
            v_center_coord = self.vertices_coords[v_center_idx]
            
            for crease_idx in connected_creases_indices:
                crease = self.creases_vertices[crease_idx]
                v_other_idx = crease[1] if crease[0] == v_center_idx else crease[0]
                v_other_coord = self.vertices_coords[v_other_idx]
                
                angle = math.atan2(v_other_coord[1] - v_center_coord[1], 
                                   v_other_coord[0] - v_center_coord[0])
                angles.append(angle)

            # 2. 角度をソート
            angles.sort()

            # 3. 折り線間の角度（sector angles）を計算
            sector_angles = []
            for i in range(len(angles)):
                angle1 = angles[i]
                angle2 = angles[(i + 1) % len(angles)] # ラップアラウンド
                diff = angle2 - angle1
                if diff < 0:
                    diff += 2 * math.pi # 角度がマイナスにならないように調整
                sector_angles.append(diff)
            
            # 全てのセクター角度の和が2π(360度)になるか簡単なサニティチェック
            if not math.isclose(sum(sector_angles), 2 * math.pi, rel_tol=EPSILON):
                violation_count += 1
                continue # この頂点は明らかに異常なので次の頂点へ

            # 4. 交互の角度の和を計算して定理をチェック
            sum1 = sum(sector_angles[0::2]) # 偶数インデックス
            sum2 = sum(sector_angles[1::2]) # 奇数インデックス

            if not math.isclose(sum1, math.pi, rel_tol=EPSILON) or \
               not math.isclose(sum2, math.pi, rel_tol=EPSILON):
                violation_count += 1
                
        return violation_count


# --- テスト用のコード ---
if __name__ == '__main__':
    # 川崎の定理に違反するテストデータ
    # 頂点0の周りの角度が90, 90, 90 -> 交互の和が 90 と 180 になり違反
    test_fold_data_kawasaki_ng = {
        "vertices_coords": [[0,0], [1,0], [0,1], [-1,0]],
        "creases_vertices": [[0,1], [0,2], [0,3]],
        "creases_assignment": ['M','V','M']
    }
    validator_ng = OrigamiValidator(test_fold_data_kawasaki_ng)
    kawasaki_violations_ng = validator_ng.check_kawasaki()
    print(f"--- 川崎の定理チェック (違反ケース) ---")
    print(f"違反している頂点の数: {kawasaki_violations_ng}") # 期待値: 1

    # 川崎の定理を満たすテストデータ
    # 頂点0の周りの角度が90, 90, 90, 90 -> 交互の和が 180, 180 でOK
    test_fold_data_kawasaki_ok = {
        "vertices_coords": [[0,0], [1,0], [0,1], [-1,0], [0,-1]],
        "creases_vertices": [[0,1], [0,2], [0,3], [0,4]],
        "creases_assignment": ['M','V','M','V']
    }
    validator_ok = OrigamiValidator(test_fold_data_kawasaki_ok)
    kawasaki_violations_ok = validator_ok.check_kawasaki()
    print(f"--- 川崎の定理チェック (正常ケース) ---")
    print(f"違反している頂点の数: {kawasonic_violations_ok}") # 期待値: 0```

### このコードのポイント
