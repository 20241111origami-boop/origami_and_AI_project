import json
import math
import sys
from collections import defaultdict, namedtuple
import itertools


EPSILON = 1e-9
def get_connected_edges_assignments(vertex_index, edges_vertices, edges_assignment):
    """指定された頂点に接続するエッジの種類（山折り、谷折りなど）を取得する"""
    assignments = []
    for i, edge in enumerate(edges_vertices):
        if vertex_index in edge:
            assignments.append(edges_assignment[i])
    return assignments


def get_angles_around_vertex(vertex_index, vertices_coords, edges_vertices):
    """指定された頂点の周りの角度を計算してリストで返す"""
    center_point = vertices_coords[vertex_index]
    
    # 頂点に接続する他の頂点の座標を取得
    connected_points = []
    for edge in edges_vertices:
        if edge[0] == vertex_index:
            connected_points.append(vertices_coords[edge[1]])
        elif edge[1] == vertex_index:
            connected_points.append(vertices_coords[edge[0]])

    if len(connected_points) < 2:
        return []

    # 各点と中心点との角度を計算
    angles_points = []
    for p in connected_points:
        angle = math.atan2(p[1] - center_point[1], p[0] - center_point[0])
        angles_points.append((angle, p))
    
    # 角度でソート
    angles_points.sort()

    # ソートされた点の間（セクター）の角度を計算
    sector_angles = []
    num_points = len(angles_points)
    for i in range(num_points):
        angle1, _ = angles_points[i]
        angle2, _ = angles_points[(i + 1) % num_points]
        diff = angle2 - angle1
        # 角度が負になる場合（360度をまたぐ場合）は2πを足す
        if diff < 0:
            diff += 2 * math.pi
        sector_angles.append(diff)
        
    return sector_angles


# 頂点周りのエッジ情報を格納するためのデータ構造
HalfEdge = namedtuple('HalfEdge', [
    'vector_angle',      # 頂点から接続先へのベクトルの角度(atan2)
    'sector_angle',      # このエッジと次のエッジが成す角度(α)
    'assignment',        # "M", "V", "B" などの種類
    'edge_indices_tuple' # (中心頂点, 接続先頂点)
])

# --- 以下の3つの関数を validator.py 内の既存のものと置き換えてください ---

def _get_orientation(p, q, r):
    """3点の位置関係（共線、時計回り、反時計回り）を返す"""
    # 浮動小数点数の計算誤差を考慮
    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
    if math.isclose(val, 0, rel_tol=EPSILON, abs_tol=EPSILON):
        return 0  # Collinear
    return 1 if val > 0 else 2  # Clockwise or Counterclockwise

def _on_segment(p, q, r):
    """点qが線分pr上にあるかどうかをチェック（3点が共線であること前提）"""
    return (q[0] <= max(p[0], r[0]) + EPSILON and q[0] >= min(p[0], r[0]) - EPSILON and
            q[1] <= max(p[1], r[1]) + EPSILON and q[1] >= min(p[1], r[1]) - EPSILON)

def check_improper_edge_intersections(vertices_coords, edges_vertices):
    """
    エッジ同士が端点以外で交差、または不適切に重なっているかを検証する。(堅牢版)
    """
    errors = []
    edge_pairs = itertools.combinations(enumerate(edges_vertices), 2)

    for (idx1, edge1), (idx2, edge2) in edge_pairs:
        v1_idx, v2_idx = edge1
        v3_idx, v4_idx = edge2

        # 頂点を共有しているエッジはチェック対象外
        if len(set(edge1) & set(edge2)) > 0:
            continue

        p1, q1 = vertices_coords[v1_idx], vertices_coords[v2_idx]
        p2, q2 = vertices_coords[v3_idx], vertices_coords[v4_idx]

        o1 = _get_orientation(p1, q1, p2)
        o2 = _get_orientation(p1, q1, q2)
        o3 = _get_orientation(p2, q2, p1)
        o4 = _get_orientation(p2, q2, q1)

        # 一般的な交差ケース: 2つの線分が互いをまたいでいる
        if o1 != o2 and o3 != o4:
            errors.append({
                "type": "ImproperEdgeIntersection",
                "message": f"Edge {idx1} ({v1_idx}-{v2_idx}) and Edge {idx2} ({v3_idx}-{v4_idx}) improperly intersect.",
                "context": {"edge_indices": [idx1, idx2], "vertex_indices": [edge1, edge2]}
            })
            continue

        # 特殊ケース: 同一直線上にある場合の「重なり」をチェック
        # p2が線分p1-q1上にあれば、重なりがあると判断
        if o1 == 0 and _on_segment(p1, p2, q1):
             errors.append({
                "type": "ImproperCollinearOverlap",
                "message": f"Edge {idx1} and Edge {idx2} are collinear and overlap.",
                "context": {"edge_indices": [idx1, idx2], "vertex_indices": [edge1, edge2]}
            })
        # q2が線分p1-q1上にあれば、重なりがあると判断
        elif o2 == 0 and _on_segment(p1, q2, q1):
             errors.append({
                "type": "ImproperCollinearOverlap",
                "message": f"Edge {idx1} and Edge {idx2} are collinear and overlap.",
                "context": {"edge_indices": [idx1, idx2], "vertex_indices": [edge1, edge2]}
            })
        # p1が線分p2-q2上にあれば、重なりがあると判断
        elif o3 == 0 and _on_segment(p2, p1, q2):
             errors.append({
                "type": "ImproperCollinearOverlap",
                "message": f"Edge {idx1} and Edge {idx2} are collinear and overlap.",
                "context": {"edge_indices": [idx1, idx2], "vertex_indices": [edge1, edge2]}
            })
        # q1が線分p2-q2上にあれば、重なりがあると判断
        elif o4 == 0 and _on_segment(p2, q1, q2):
             errors.append({
                "type": "ImproperCollinearOverlap",
                "message": f"Edge {idx1} and Edge {idx2} are collinear and overlap.",
                "context": {"edge_indices": [idx1, idx2], "vertex_indices": [edge1, edge2]}
            })

    return errors if errors else None



def check_vertices_within_boundary(vertices_coords, x_range=(-200, 200), y_range=(-200, 200)):
    """
    全ての頂点が指定された境界内に存在するかを検証する。
    境界のデフォルト値は (-200, 200) に設定されています。
    """
    errors = []
    # x_rangeとy_rangeの最小値・最大値が正しい順序であることを確認
    x_min, x_max = min(x_range), max(x_range)
    y_min, y_max = min(y_range), max(y_range)

    for i, coord in enumerate(vertices_coords):
        # 座標がNoneや不正な形式でないことを確認
        if coord is None or len(coord) != 2:
            errors.append({
                "type": "InvalidCoordinateFormat",
                "vertex": i,
                "message": f"Vertex {i} has invalid coordinate format: {coord}.",
                "context": {"coords": coord}
            })
            continue
            
        x, y = coord
        # 判定ロジック: 許容誤差(EPSILON)を含めて範囲内かをチェック
        if not (x_min - EPSILON <= x <= x_max + EPSILON and
                y_min - EPSILON <= y <= y_max + EPSILON):
            errors.append({
                "type": "VertexOutOfBounds",
                "vertex": i,
                "message": f"Vertex {i} with coordinates ({x:.4f}, {y:.4f}) is outside the defined boundary.",
                "context": {
                    "coords": [x, y],
                    "x_boundary": [x_min, x_max],
                    "y_boundary": [y_min, y_max]
                }
            })
            
    return errors if errors else None

def get_ordered_half_edges(vertex_index, vertices_coords, edges_vertices, edges_assignment):
    """
    頂点に接続するハーフエッジを物理的にソートし、各セクターの角度と共に返す。
    """
    center_point = vertices_coords[vertex_index]
    
    # 頂点に接続するエッジとその接続先の情報を収集
    connected_edges = []
    for i, edge in enumerate(edges_vertices):
        if edge[0] == vertex_index:
            other_v_idx = edge[1]
            connected_edges.append({'assignment': edges_assignment[i], 'other_v': other_v_idx})
        elif edge[1] == vertex_index:
            other_v_idx = edge[0]
            connected_edges.append({'assignment': edges_assignment[i], 'other_v': other_v_idx})

    if len(connected_edges) < 2:
        return []

    # 各接続先へのベクトル角度(atan2)を計算
    sorted_edges_info = []
    for edge_info in connected_edges:
        p_coords = vertices_coords[edge_info['other_v']]
        angle = math.atan2(p_coords[1] - center_point[1], p_coords[0] - center_point[0])
        sorted_edges_info.append({
            'vector_angle': angle,
            'assignment': edge_info['assignment'],
            'other_v': edge_info['other_v']
        })
    
    # ベクトル角度で反時計回りにソート
    sorted_edges_info.sort(key=lambda x: x['vector_angle'])

    # HalfEdgeオブジェクトのリストを生成
    half_edges = []
    num_edges = len(sorted_edges_info)
    for i in range(num_edges):
        current_edge = sorted_edges_info[i]
        next_edge = sorted_edges_info[(i + 1) % num_edges]
        
        # 2つのベクトル間の角度（セクター角度）を計算
        sector_angle = next_edge['vector_angle'] - current_edge['vector_angle']
        if sector_angle < 0:
            sector_angle += 2 * math.pi
            
        half_edges.append(HalfEdge(
            vector_angle=current_edge['vector_angle'],
            sector_angle=sector_angle,
            assignment=current_edge['assignment'],
            edge_indices_tuple=(vertex_index, current_edge['other_v'])
        ))
        
    return half_edges


def check_boundary_count(assignments, vertex_index):
    """頂点に接続する境界線の数が0または2であるかを検証する"""
    b_count = assignments.count("B")
    if b_count not in [0, 2]:
        return {
            "type": "BoundaryCount",
            "vertex": vertex_index,
            "message": f"Vertex {vertex_index} has an invalid number of boundary edges. Expected 0 or 2, but found {b_count}.",
            "context": {
                "boundary_count": b_count,
                "expected_values": [0, 2]
            }
        }
    return None


# --- ここから新しいコードを追加 ---
def check_overlapping_creases(ordered_half_edges, vertex_index):
    """
    頂点から伸びる折り線が幾何学的に重複していないかを検証する。
    入力リストはベクトル角度でソート済みであることを前提とする。
    """
    num_edges = len(ordered_half_edges)
    if num_edges < 2:
        return None

    for i in range(num_edges):
        # 隣接するエッジを比較。リストは循環しているとみなす。
        current_he = ordered_half_edges[i]
        next_he = ordered_half_edges[(i + 1) % num_edges]

        if math.isclose(current_he.vector_angle, next_he.vector_angle, rel_tol=EPSILON, abs_tol=EPSILON):
            # 重複を検出
            return {
                "type": "OverlappingCreases",
                "vertex": vertex_index,
                "message": f"Vertex {vertex_index} has geometrically overlapping creases.",
                "context": {
                    "overlapping_angle_deg": math.degrees(current_he.vector_angle),
                    # 重複している線の先の頂点IDを取得
                    "involved_vertices": sorted([
                        current_he.edge_indices_tuple[1],
                        next_he.edge_indices_tuple[1]
                    ])
                }
            }
    return None
def check_maekawa_theorem(assignments, vertex_index):
    """前川の定理を検証する: |M - V| = 2"""
    m_count = assignments.count("M")
    v_count = assignments.count("V")
    if abs(m_count - v_count) != 2:
        return {
            "type": "Maekawa",
            "vertex": vertex_index,
            "message": f"Vertex {vertex_index} fails Maekawa's theorem. |M({m_count}) - V({v_count})| = {abs(m_count - v_count)}, but should be 2."
        }
    return None


def check_kawasaki_theorem(angles, vertex_index):
    """川崎の定理を検証する: 交互の角度の和がそれぞれ180度になる"""
    if not angles or len(angles) % 2 != 0:
        # 奇数個の角度では定理は適用できない
        return {
            "type": "Kawasaki",
            "vertex": vertex_index,
            "message": f"Vertex {vertex_index} has an odd number of angles ({len(angles)}), which is not typical for flat-foldable interior vertices."
        }

    # 角度の総和が360度(2π)であるかチェック
    if not math.isclose(sum(angles), 2 * math.pi):
        return {
            "type": "Kawasaki",
            "vertex": vertex_index,
            "message": f"Vertex {vertex_index} angles do not sum to 360 degrees. Sum is {math.degrees(sum(angles)):.2f}."
        }
    
    # 交互の角度の和を計算
    odd_sum = sum(angles[i] for i in range(0, len(angles), 2))
    even_sum = sum(angles[i] for i in range(1, len(angles), 2))

    if not math.isclose(odd_sum, even_sum):
        return {
            "type": "Kawasaki",
            "vertex": vertex_index,
            "message": (
                f"Vertex {vertex_index} fails Kawasaki's theorem. "
                f"Alternating angle sums are not equal. "
                f"Odd sum: {math.degrees(odd_sum):.2f}, Even sum: {math.degrees(even_sum):.2f}."
            )
        }
    return None


# --- この関数を既存の check_big_little_big_theorem と置き換える ---
def check_big_little_big_theorem(ordered_half_edges, vertex_index):
    """
    Big-Little-Big定理から導かれる局所的な条件を検証する。
    ルール: 連続する3つのセクター角 a1, a2, a3 について、もし a1 > a2 かつ a3 > a2 ならば、
          a2 を形成する2本の折り線(e2, e3)の割り当ては異ならなければならない (M/V)。
    """
    num_edges = len(ordered_half_edges)
    if num_edges < 3:
        # 3辺未満の頂点では、この条件は適用できない
        return None

    for i in range(num_edges):
        # 連続する3つのセクター角を循環的に取得する
        # he_prev.sector_angle は a1 に相当
        # he_min.sector_angle  は a2 に相当
        # he_next.sector_angle は a3 に相当
        he_prev = ordered_half_edges[i]
        he_min  = ordered_half_edges[(i + 1) % num_edges]
        he_next = ordered_half_edges[(i + 2) % num_edges]

        angle1 = he_prev.sector_angle
        angle2 = he_min.sector_angle
        angle3 = he_next.sector_angle

        # 条件: angle1 > angle2 かつ angle3 > angle2 (angle2が局所最小角)
        # 浮動小数点数の比較のため、A > B を A - B > EPSILON でチェック
        if (angle1 - angle2 > EPSILON) and (angle3 - angle2 > EPSILON):
            # 条件を満たした場合、angle2を形成する2本の折り線の割り当てをチェックする。
            # angle2 (he_min.sector_angle) は、折り線 he_min と he_next によって形成される。
            assignment1 = he_min.assignment
            assignment2 = he_next.assignment

            # M(山折り)またはV(谷折り)でない場合はチェック対象外
            if assignment1 not in ["M", "V"] or assignment2 not in ["M", "V"]:
                continue

            # 割り当てが同じであればルール違反
            if assignment1 == assignment2:
                return {
                    "type": "BigLittleBigCondition",
                    "vertex": vertex_index,
                    "message": (
                        f"Vertex {vertex_index} fails the local minima condition (derived from Big-Little-Big). "
                        f"The two creases forming a local minimum angle must have different assignments (one mountain, one valley)."
                    ),
                    "context": {
                        "local_minimum_angle_deg": math.degrees(angle2),
                        "surrounding_angles_deg": [math.degrees(angle1), math.degrees(angle3)],
                        "conflicting_assignments": [assignment1, assignment2],
                        "involved_vertices": sorted([
                            he_min.edge_indices_tuple[1],
                            he_next.edge_indices_tuple[1]
                        ])
                    }
                }
    
    # 全ての局所最小角でルールが満たされた
    return None



# --- 元の check_generalized_blb_lemma を以下の3つの関数に置き換える ---

def find_equal_angle_sequences(sector_angles):
    """
    角度のリストから、連続する等しい角度のシーケンスを特定する。
    戻り値: [(開始インデックス, シーケンスの長さ), ...] のリスト
    """
    num_angles = len(sector_angles)
    if num_angles == 0:
        return []

    sequences = []
    visited = [False] * num_angles
    
    # 1周して全ての角度が等しいかチェック
    all_equal = True
    for i in range(1, num_angles):
        if not math.isclose(sector_angles[0], sector_angles[i], rel_tol=EPSILON, abs_tol=EPSILON):
            all_equal = False
            break
    if all_equal:
        return [] # 全ての角度が等しい場合、補題は適用されない

    for i in range(num_angles):
        if visited[i]:
            continue
            
        # iから始まる等角シーケンスを探索
        seq_length = 1
        j = i
        
        while math.isclose(sector_angles[j], sector_angles[(j + 1) % num_angles], rel_tol=EPSILON, abs_tol=EPSILON):
            seq_length += 1
            j = (j + 1) % num_angles
            visited[j] = True
        
        # シーケンス長が1より大きい（＝等角が連続している）場合のみ追加
        if seq_length > 1:
            sequences.append((i, seq_length))

    return sequences


def validate_blb_sequence(ordered_half_edges, vertex_index, seq_start, seq_length):
    """特定された一つの等角シーケンスに対して、補題のルールを検証する"""
    num_edges = len(ordered_half_edges)
    sector_angles = [he.sector_angle for he in ordered_half_edges]

    # シーケンスの前後の角度を取得
    seq_end = (seq_start + seq_length - 1) % num_edges
    alpha_s = sector_angles[seq_start]
    alpha_prev = sector_angles[(seq_start - 1 + num_edges) % num_edges]
    alpha_next = sector_angles[(seq_end + 1) % num_edges]

    # 適用条件のチェック: α_prev > α_s AND α_next > α_s
    if (alpha_prev - alpha_s > EPSILON) and (alpha_next - alpha_s > EPSILON):
        # seq_length個の角度は、seq_length + 1本のエッジで形成される
        edge_count = seq_length + 1
        mountain_count = 0
        valley_count = 0

        # 該当するエッジの山・谷を数える
        for k in range(edge_count):
            edge_idx = (seq_start + k) % num_edges
            assignment = ordered_half_edges[edge_idx].assignment
            if assignment == "M":
                mountain_count += 1
            elif assignment == "V":
                valley_count += 1
        
        # ルール検証
        error_condition = None
        if edge_count % 2 == 0: # 偶数本
            if mountain_count != valley_count:
                error_condition = "mountain_count == valley_count"
        else: # 奇数本
            if abs(mountain_count - valley_count) != 1:
                error_condition = "abs(mountain_count - valley_count) == 1"

        if error_condition:
            return {
                "type": "GeneralizedBigLittleBigLemma",
                "vertex": vertex_index,
                "message": f"Vertex {vertex_index}: " + (
                    f"An even-edge ({edge_count}) equal-angle sequence does not have the same number of mountains and valleys."
                    if edge_count % 2 == 0 else
                    f"An odd-edge ({edge_count}) equal-angle sequence does not have a mountain/valley count difference of 1."
                ),
                "context": {
                    "violating_sequence_angle_deg": math.degrees(alpha_s),
                    "sequence_length_in_angles": seq_length,
                    "edge_count": edge_count,
                    "mountain_count": mountain_count,
                    "valley_count": valley_count,
                    "expected_condition": error_condition
                }
            }
            
    return None


def check_generalized_blb_lemma(ordered_half_edges, vertex_index):
    """
    一般化された大小大の補題（Generalized Big-Little-Big Lemma）を検証する。(安全な実装)
    """
    num_edges = len(ordered_half_edges)
    if num_edges < 3:
        return None

    # M/V以外の割り当てが含まれる場合はチェック対象外
    if any(he.assignment not in ["M", "V"] for he in ordered_half_edges):
        return None

    sector_angles = [he.sector_angle for he in ordered_half_edges]
    
    # 全ての等角シーケンスを事前に特定
    equal_sequences = find_equal_angle_sequences(sector_angles)
    
    for seq_start, seq_length in equal_sequences:
        # 各シーケンスに対して補題を適用
        error = validate_blb_sequence(ordered_half_edges, vertex_index, seq_start, seq_length)
        if error:
            return error # 最初の違反が見つかった時点でエラーを返す
    
    return None # 全てのシーケンスがルールを満たした

# validator.py の先頭に追加

# --- validate_fold_file 関数を以下のように修正 ---

def validate_fold_file(file_path):
    """
    .foldファイルを読み込み、平坦折り畳み可能性のルールを検証する (最終版)
    """
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError) as e:
        return {"valid": False, "errors": [{"type": "File Error", "message": str(e)}]}

    required_keys = ["vertices_coords", "edges_vertices", "edges_assignment"]
    for key in required_keys:
        if key not in data:
            return {"valid": False, "errors": [{"type": "Format Error", "message": f"Missing required key: '{key}'"}]}

    vertices_coords = data["vertices_coords"]
    edges_vertices = data["edges_vertices"]
    edges_assignment = data["edges_assignment"]
    
    errors = []

    # --- レベル0-Global: 全体的な幾何学的健全性チェック ---
    global_errors = []
    
    # [新規] 頂点が境界内に収まっているか
    boundary_errors = check_vertices_within_boundary(vertices_coords)
    if boundary_errors: global_errors.extend(boundary_errors)

    # [新規] エッジが不適切に交差していないか
    intersection_errors = check_improper_edge_intersections(vertices_coords, edges_vertices)
    if intersection_errors: global_errors.extend(intersection_errors)
    
    if global_errors:
        # 大域的なエラーがあれば、頂点ごとのチェックは行わずに終了
        return {"valid": False, "errors": global_errors}

    # --- 各頂点についてループ (既存のチェック) ---
    for i in range(len(vertices_coords)):
        # --- レベル0-Local: 頂点周りの基本的な健全性チェック ---
        assignments = get_connected_edges_assignments(i, edges_vertices, edges_assignment)
        
        error = check_boundary_count(assignments, i)
        if error:
            errors.append(error)
            continue # この頂点の以降のチェックはスキップ

        ordered_half_edges = get_ordered_half_edges(i, vertices_coords, edges_vertices, edges_assignment)
        if not ordered_half_edges:
            continue
        
        error = check_overlapping_creases(ordered_half_edges, i)
        if error:
            errors.append(error)
            continue

        # 境界頂点(Bの数が2)の場合、内点向けの定理は適用しない
        if assignments.count("B") > 0:
            continue

        # --- レベル1: 内点向けの必要条件チェック ---
        level1_errors = []
        level1_errors.append(check_maekawa_theorem(assignments, i))
        
        sector_angles_rad = [he.sector_angle for he in ordered_half_edges]
        level1_errors.append(check_kawasaki_theorem(sector_angles_rad, i))
        level1_errors.append(check_big_little_big_theorem(ordered_half_edges, i))
        level1_errors.append(check_generalized_blb_lemma(ordered_half_edges, i))
        
        level1_errors = [e for e in level1_errors if e is not None]
        if level1_errors:
            errors.extend(level1_errors)

    if errors:
        return {"valid": False, "errors": errors}
    
    return {"valid": True, "errors": []}



if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python validator_v4.py <path_to_fold_file>")
        sys.exit(1)
        
    file_path = sys.argv[1]
    result = validate_fold_file(file_path)
    print(json.dumps(result, indent=2))
